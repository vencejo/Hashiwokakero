{"name":"Hashiwokakero","tagline":"Proyecto de un juego lógico en Java para la UNED","body":"Proyecto Final de la UNED (Curso 09-10)\r\n===========================================================\r\nLenguaje Java\r\n\r\nEnunciado del Proyecto\r\n----------------------\r\n[Hashiwokakero](http://es.wikipedia.org/wiki/Hashiwokakero) es un puzzle lógico original de Nikoli.\r\nEl pasatiempo consiste en un tablero rectangular, aunque el tablero en sí no se suele\r\ndibujar, en el que algunas celdas contendrán números con valores del 1 al 8, que\r\naparecen dentro de un círculo y que representan “islas”. El resto de las celdas estarán\r\nvacías. El objetivo es conectar todas las islas dibujando “puentes” (aristas) entre las\r\nislas. Los puentes deben cumplir las siguientes condiciones:\r\n\r\nDeben comenzar y acabar en distintas islas mediante una línea recta.\r\nNo pueden cruzar otros puentes u otras islas.\r\nLas líneas rectas deben ser horizontales o verticales.\r\nComo mucho puede haber dos puentes paralelos que conecten un par de islas.\r\nAl final, el número de puentes conectados a cada isla debe coincidir con el\r\nnúmero de la isla.\r\n\r\n\r\nFuncionamiento\r\n--------------\r\nEl programa se puede invocar desde la línea de comandos de Linux (ó\r\nWindows) con la siguiente sintaxis:\r\n\r\n$> java hashiwokakero [-h] [fichero]\r\n\r\nLos argumentos son:\r\nfichero: el nombre del archivo que contiene los datos de entrada.\r\n-h: modo ayuda. Muestra la sintaxis y los créditos.\r\n\r\nEl programa leerá los datos del fichero que se le pase como argumento. Por ejemplo:\r\n\r\nC:\\> java hashiwokakero tablero.txt <ENTER>\r\n\r\no también desde la entrada estándar (stdin):\r\n\r\nC:\\> java hashiwokakero < tablero.txt <ENTER>\r\n\r\no también usando pipe (tubería)\r\n\r\nC:\\> type tablero.txt | java hashiwokakero<ENTER>\r\n\r\ny saca por la salida estándar el tablero solución o una indicación de que no hay solución\r\nsi ese es el caso.\r\n\r\n\r\nDescripción y justificación del tipo de Algoritmo Utilizado\r\n----------------------------------------------------------\r\nPuesto que el tomar la decisión de tender un puente afecta tanto a las celdas vecinas como a otras\r\nceldas distantes, vemos que el problema no puede ser descompuesto en otros de menor tamaño, por\r\nlo que no puede usarse el esquema de Divide y Vencerás.\r\nLa resolución a mano de algún hashiwokakero sencillo pronto nos hace comprender que se trata de\r\nun juego de ensayo y error en el que no vasta aplicar una serie de reglas ciegas como en el caso del\r\nesquema Voraz ya hay que estar muy atento al contexto del problema.\r\nEsto, unido a que nos encontramos ante un grafo en el que solo hace falta encontrar una única\r\nsolución y no hay condiciones de optimización, nos induce a pensar que el enfoque correcto para\r\neste problema es el del algoritmo de Vuelta Atrás.\r\n\r\nGlosario de términos\r\n-------------------\r\n– Hashi: Los objetos de esta clase representan la situación del tablero en un momento dado\r\nmediante un par de conjuntos de puentes (verticales y horizontales) y un par de listas,\r\nListaDeIslas y listaDeCandidatas.\r\n– Isla: Objeto con los atributos fila, columna y valor que representa a uno de los valores\r\nnuméricos de la cuadrícula.\r\n– ListaDeIslas: Es un atributo de la clase Hashi que tiene forma de ArrayList<Isla> donde se\r\nguardan las islas del Hashi cuyo valor sea distinto de cero. El algoritmo de resolución\r\ndisminuye en uno el valor de las islas que acaban de formar un puente y va quitando de la\r\nListaDeIslas a las islas cuyo valor llega a cero, así cuando esla ListaDeIslas llega a cero se\r\nha llegado a una solución del Hashi.\r\n– Las islas \"Agotadas\" son las que han tendido todos sus puentes y ya no aparecen en la\r\nListaDeIslas del Hashi.\r\n– Las islas vecinas a la isla considerada son con las que se está en condiciones de tender\r\nalgun puente a partir de la isla dada.\r\n– Isla candidata: Una isla que ya tiene tendido algún puente y es susceptible de tender\r\nalguno más. El algoritmo de resolución utilizado va tendiendo puentes que salen de la lista\r\nde islas candidatas, favoreciendo así la formación de la única región conexa que nos exige el\r\nenunciado del problema.\r\n– Isla afortunada: Entiendo por \"Isla Afortuanada\" a aquella a la que le es indiferente la\r\ndireccion que tome su proximo puente, tiende todos sus puentes hacia las vecinas de manera\r\nforzada. Esta rodeada por una serie de vecinas y a todas tiene que tender al menos un\r\npuente.\r\n– Entiendo por \"Isla semi Afortuanada\" a aquella a la que le es indiferente la direcciones\r\nque tomen sus puentes, menos el último , que queda indefinido.\r\nSe da en el caso de islas con valor impar\r\nP.ej. una isla de valor 3 rodeada por dos vecinas, una de valor 5 rodeada por 3 vecinas y una\r\nde valor 7 rodeada por 4 vecinas\r\n– Puente: Objeto que representa el puente tendido entre dos islas, sus atributos son las islas\r\nimplicadas, el tipo de puente (simple o doble), su orientación (horizontal o vertical) y un par\r\nde arrays donde guardamos las filas y las columnas por las que atraviesa el puente.\r\n\r\nEstrategias locales consideradas y condiciones de poda\r\n------------------------------------------------------\r\n\r\n– inicialmenteValido() : Para que un hashi sea inicialmente valido el valor acumulado de sus\r\nislas en la lista ha de ser par.\r\n– parcialmenteValido(): Un Hashi sera parcialmente valido cuando:\r\nEl valor de una isla (el num de puentes a tender a partir de una isla) sea menor o igual\r\nal num de puentes posibles con sus vecinas a partir de esa isla en el momento actual.\r\nCon esto evito situaciones del tipo : (2)--(2) y (1)--(3)--(1) donde el número de puentes\r\nque se pueden tender es menor al necesario para dejar a cero los valores de las islas.\r\n– PotencialmenteConexo(): Un hashi es potencialmenteConexo cuando las islas que ya no\r\nestán en la lista de islas (las islas \"Agotadas\" que han tendido todos sus puentes) PUEDEN\r\nSER conectadas mediante algún camino a alguna isla que aún está en la lista de Islas. De no\r\nser así se estarían formando regiones inconexas, incompatibles con la solución correcta del\r\nproblema. Utilizo un recorrido en anchura basado en la estructura de datos de cola para\r\nimplementar este método.\r\n4- Heurísticas\r\n- La clase Tratamiento: Esta clase se encarga de tratar los Hashis realizando sucesivas\r\npasadas en busca de islas afortunadas y\r\nsemi afortunadas para tender los puentes de las mismas y devolver al hashi ya tratado.\r\nEsta clase se utiliza en dos contextos:\r\n1- Con el método \"generarHashiInicial\" ,al iniciar el programa para realizar\r\nel pretratamiento del tablero inicial en busca de afortunadas antes de pasárselo al\r\nalgoritmo de vuelta atras ,\r\nesto puede facilitarle mucho las cosas al vuelta atrás pues puede que este tratamiento\r\nsimplifique sobremanera el tablero inicial.\r\n2- Dentro del algoritmo vuelta atrás cuando se genera un ensayo tendiendo un puente\r\nentre las islas se llama seguidamente al\r\nmétodo \"tratarHashi\" para que compruebe si el nuevo puente ha provocado la creación\r\nde nuevas afortunadas o semiafortunadas.\r\n- En el método islasVecinas ( isla):\r\n1- si la vecina mirada no tiene a su vez vecinas, el puente con la isla original es\r\nobligado y por tanto , para favorecer cuanto antes su formación, lo pongo al principio de\r\nla lista de vecinas\r\n2 - para favorecer la creación de puentes simples frente a los dobles\r\nSi no hay ningún puente previo entre ambas, la isla mirada se pone al\r\nprincipio de la lista de vecinas.\r\n- En el método tenderPuente(islaA, islaB):\r\nPara evitar la rapida formacion de puentes dobles:\r\nsi alguna de estas islas solo puede tender puentes dobles (tiene ya puentes con todas\r\nsus vecinas ) la pongo al final de la lista de candidatas, recolocando la lista de\r\ncandidatas.\r\n- En el método recolocaCandidatas():\r\nPara evitar la rapida formacion de puentes dobles:\r\nvoy revisando la lista de las candidatas y si alguna de estas islas\r\nsolo puede tender puentes dobles (tiene ya puentes con todas\r\nsus vecinas ) la pongo al final de la lista de candidatas.\r\n- En el método compleciones( hashi):\r\nOrdeno la lista de hashis nuevos según la longitud de su lista de canditatas de menor a\r\nmayor, generalmente la accion de poner primero las compleciones mas restrictivas hace\r\nmás eficiente la vuelta atras (wikipedia).\r\n-En el método vueltaAtras(hashi, myEntSal, depuracion):\r\nHago una revisión de los avances del algoritmo cada diez nodos: si no se ha disminuido\r\nsignificativamente el numero de islas (si no ha disminuido la cota) es que no hay\r\navances y entonces recomienzo con el siguiente hashi de las compleciones del hashi\r\ninicial. Si por el contrario si se han producido avances, actualizo el valor de la cota ,\r\ndisminuyéndolo al numero de islas actual\r\n\r\nAnálisis del coste\r\n-----------------\r\nEn el estudio del coste en los algoritmos de vuelta atrás es difícil dar una solución exacta, ya que\r\nse desconoce el tamaño de lo explorado a priori, (puede que las heurísticas funcionen muy bien en\r\nla mayoria de los casos, pero que no lo hagan en absoluto en algún otro) , así que solo es posible en\r\nla mayoría de los casos dar una cota superior al tamaño de la búsqueda.\r\nAsí que ,tal y como se ha construido el programa , se considera que en cada nodo del árbol de\r\nbúsqueda se tiene un tablero hashi , y para el tablero selecciono una isla candidata, y a partir de esa\r\nisla tiendo un puente con alguna de sus vecinas .\r\nDado que una isla tiene un máximo de cuatro vecinas tengo cuatro posibilidades de tender un\r\npuente para una candidata , suponiendo que todas las n islas del hashi fuesen candidatas tendríamos\r\n4n posibilidades, lo que nos da un coste exponencial para el algoritmo, (en el caso peor).\r\nEste factor exponencial querría decir que el problema es irresoluble, en la práctica , para valores\r\ngrandes de n.\r\nEn general se puede considerar que si β es el índice de ramificación del árbol y γ es el número de\r\nelementos que componen una solución, o lo que es lo mismo, la profundidad del arbol de búsqueda,\r\nvamos en realidad a tener como máximo β γ pasos para alcanzar todas las soluciones. Si además se\r\nintroducen condiciones de poda, éstas influyen reduciendo el índice de ramificación. La poda\r\nademás dependerá de la profundidad p y del número n de piezas disponibles para completar la\r\nsolución. El coeficiente de poda es un valor entre 0 y 1, si el coeficiente de poda es 0, no existen\r\ncondiciones de poda y la búsqueda es totalmente ciega, si es 1 no habrá ramificación. La expresión\r\ngeneral sería [ β (1 - ζ(n , p))] γ . En este problema β = 4 , γ = n y ζ es una función que varía entre\r\n0 y β – 1 / β.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}